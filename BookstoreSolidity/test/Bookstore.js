var Bookstore = artifacts.require("./Bookstore.sol");


contract('Bookstore', function(accounts) {                            	// initialize contract.  accounts represents the generated user accounts from testrpc
	it("should set the owner's address successfully", function() {    	// message for the test runner indicating what the test should accomplish
    	return Bookstore.deployed().then(function(instance) {			// instance refers to the instantiation of the contract (same as Bookstore.deployed().  
    																	// it is calling the instance to be able to access its member functions
    																
      		return instance.getOwner.call();							// calls getOwner and returns the result of the call (should be owner address)
    	}).then(function(owneraddress) {								// function(owneraddress) sets owneraddress to the return value of the previous function call
      		assert.equal(owneraddress, accounts[0], "Owner address is incorrect");		// assert that the owneraddress is equal to the first account in the generated testrpc accounts
    	});
  	});

  	it("should be able to create new users and add books to their accounts", function() {
  		var store;						// variable for the instance of the deployed contrace
  		var bookID = 100; 				// edition ID for a book
		var public_key = 10101010; 		// public key for a book copy (generated by the user)

  		return Bookstore.deployed().then(function(instance) {
			store = instance;
			return instance.createUser({from: accounts[1]});
		 }).then(function () {
		 	return store.getUsers.call();
		 }).then(function (result) {
		 	var user0 = result[0];
		 	var numusers = result.length;
		 	
		 	assert.equal(numusers,1, "One user should have been created");
		 	assert.equal(user0,accounts[1], "User should be "+accounts[1]);
		 	return store.userExists.call(accounts[1]);
		 }).then(function (result) {
		 	assert.ok(result, "User "+accounts[1]+" should have been created");
		 	return store.userExists.call(accounts[2]);
		 }).then(function (result) {
		 	assert.ok(!result, "User "+accounts[2]+" should not have been created");
		 	
		 	return store.sendBooktoUser(bookID,public_key,{from: accounts[1]});
		 }).then(function () {
		 	return store.getBook.call(0);
		 }).then(function (result) {
		 	assert.equal(result[0],bookID, "Book that was assigned should exist and have editionID "+bookID);
		 	assert.equal(result[1],public_key, "Book that was assigned should exist and have public key "+public_key);
		 	return store.getUser.call(accounts[1]);
		 }).then(function (result) {
		 	assert.equal(result[0],0, "User "+accounts[1]+" should own book index 0");
		 });
	});  			
});
